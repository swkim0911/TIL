# HTTPS 통신

## HTTPS (HTTP over TLS)
HTTPS은 웹 브라우저와 웹 사이트 간에 데이터를 전송하는데 사용되는 기본 프로토콜인 HTTP의 보안 버전이다. HTTPS를 사용하면 패킷을 스니핑하거나 가로챈다고 해도 암호화된 문자로 인식된다.

### HTTPS를 사용하는 이유
- 데이터 암호화: SSL/TLS 기술을 사용해 사용자와 서버 간의 모든 통신을 암호화한다. 이로 인해 민감한 데이터가 전송 중 탈취되는 것을 방지할 수 있다.

- 서버 인증: 웹사이트가 신뢰할 수 있는, 인증 기관(CA)을 통해 인증된 서버임을 증명한다. 이는 사용자가 접속하려는 사이트가 사칭된 가짜 사이트가 아님을 확인하게 해준다.

- 데이터 무결성: 통신 내용이 전송 중에 변조되지 않았음을 보장한다.

## SSL / TLS
SSL(Secure Sockets Layer)과 TLS(Transport Layer Security)는 모두 암호화된 데이터 전송을 위한 프로토콜이다. TLS는 SSL의 더욱 안전하고 업그레이드된 버전이다.

> SSL 인증서로 표기하더라도, 실제로는 TLS 인증서라고 보면 된다.

### 암호화 방식
SSL 인증서의 동작 원리를 이해하려면, 암호화 방식을 이해하고 있어야 한다. 

여기서 암호화란 [키] + [데이터]를 이용해서 [암호화된 데이터]를 만들어 내는 것을 말하고 복호화란 [암호화된 데이터] + [키]를 이요해서  [데이터 원본]을 얻는 것이다.
#### 대칭키 암호화(Symmetric Key Cryptosystem)
대칭 키 암호화란, 암호화를 하는 키와 복호화를 하는 키가 동일한 방식이다. 이때 암호화와 복호화에 동시에 사용되는 키를 **대칭 키**라고 한다.

대칭 키 방식은 빠르고 효율적이지만, 서로 통신하는 발신자와 수신자 양 측이 같은 키를 사용하기 위해 키를 전송하는 과정에서 제 3자가 입수 등의 문제가 발생할 수 있다.

#### 비대칭키 암호화(Asymmetric Key Cryptosystem)
발신자와 수신자가 서로 다른 암호화 키 및 복호화 키를 사용하는 방식을 말한다. 즉, 모두에게 공개 가능한 공개 키와 모두에게 비밀로 해두고 한 쪽에서만 사용하는 비밀 키를 사용한다. 이 둘은 키 페어(Key Pair) 관계, 즉 쌍으로 존재한다.(한 쪽의 키만 가지고 다른 키를 만들거나, 암호화된 데이터를 해독할 수 없음) 

따라서, 한 쪽의 비밀 키를 전송하지 않아도 되므로 키 분배 문제를 없앨 수 있다. 하지만 처리가 복잡하기 때문에 그만큼 속도가 비교적 느리다.

1. 수신자는 공개 키와 비밀 키를 함께 만듦(키 페어)
2. 수신자는 공개 키를 모두에게 배포, 비밀 키는 보관
3. 발신자는 공개 키로 데이터를 암호화하여 송신
4. 수신자는 비밀 키로 수신한 데이터를 복호화

#### 하이브리드 암호화
발신자가 비대칭 키 방식의 공개 키로 대칭 키(공용 키)를 암호화하여 상대방에게 전송한 후, 수신자가 비밀 키로 해당 대칭 키를 복화화 하는 방식을 의미한다. 이 후 메세지는 대칭 키를 이용하여 암호화/복호화를 하게 된다.

이렇게 해서 대칭 키 방식의 장점인 빠른 속도와 비대칭 키 방식의 장점인 키 분배 문재 해결을 동시에 갖는다. SSL은 바로 이 하이브리드 방식을 이용하고 있다.

1. 수신자는 공개 키와 비밀 키를 만듦(키 페어)
2. 수신자는 공개 키를 모두에게 배포, 비밀 키는 보관
3. 발신자는 공개 키로 공용 키를 암호화하여 수신자에게 전송
4. 수신자는 비밀 키로 공용 키를 복호화 -> 공용 키가 양 측 모두에게 있는 상태가 됨
5. 발신자는 공용 키로 데이터를 암호화하여 송신
6. 수신자는 공용 키로 수신한 데이터를 복호화

## SSL 인증서 동작 원리
### SSL 인증서 발급 과정
서버에서 HTTPS 프로토콜을 사용하기 위해서는 인증 기관(CA)으로 부터 SSL 인증서를 발급받아야 되며 그 과정은 아래와 같다.

1. 서버에서 공개 키, 비밀 키(개인 키)를 생성한다.
2. CSR(Certificate Signing Request) 생성
   - CSR에는 아래 정보가 담긴다
     - 서버 공개 키
     - 서버의 각종 정보(서버의 도메인 포함)
3. CSR을 CA(Let's Encrypt)에 제출
4. CA가 서버의 도메인 소유 여부를 검증
5. 검증 통과 시 CA가 인증서를 발급
   - CA 자신의 개인 키로 서명
   - 인증서에 서버의 공개 키 평문 포함
6. 서명된 SSL 인증서를 서버에 전달

#### CA의 서명

CA는 서버의 정보과 공개 키를 받으면, 해당 공개키를 해시하여 인증서에 등록한다. 이 해시캆을 Finger Print(지문)라고 한다. 또한 이 지문을 CA의 비밀 키로 암호화하여 인증서에 '서명'한다. 즉, 이렇게 공개키를 해싱하고, 그 해시값을 CA의 개인키로 암호화하는 과정은 서명한다고 한다.

이후 브라우저는 CA의 공개키를 이용해 서명을 복호화하여 이 값을 서버의 공개 키를 해시한 값(지문)과 비교하여 인증서가 위조되지 않았음을 검증한다. 인증서의 유효성이 확인되면, 브라우저는 인증서에 있는 서버의 공개 키를 추출한다.

### SSL HandShake
서버가 인증서를 발급받고, 설치를 모두 끝내면 SSL에서는 바로 데이터를 암호화해서 전송하지 않고 먼저 SSL HandShake라는 과정을 거쳐서 세션을 맺는다. 그 과정은 아래와 같다.

#### 1. 클라이언트 -> 서버 연결 시도
클라이언트는 서버에게 'Client Hello' 패킷을 보내며 연결을 시도한다. 자신이 사용 가능한 cipher suite 목록 등을 포함한다.

#### 2. 서버 -> 클라이언트 응답
서버는 클라이언트의 'Client Hello' 메시지를 받고 클라이언트가 제안한 cipher suite 중 하나를 선택하여 'Server Heelo'로 응답한다.

#### 3. 서버 인증서 전달
서버는 자신의 인증서를 클라이언트에게 전송한다. 인증서에는 서버의 공개키, 유효 기간, 서명 등이 포함되어 있다. 클라이언트는 전달받은 서버의 인증서를 검증한다.

#### 4. 클라이언트 -> 서버 대칭키 전달
클라이언트는 서버의 공개키를 사용하여 Pre-Matser Secret을 암호화하여 이를 서버에게 전송한다. 서버는 자신의 개인키로 이를 복호화하여 Pre-Master Secret을 획득한다.

> Pre-Master Secret + 난수를 이용해 실제로 사용될 대칭 세션키를 만들어낸다.

#### 5. Change Cipher Spec
이후 클라이언트는 Change Cipher Spec 메시지를 서버에게 보내어 이제부터 암호화된 통신을 시작하겠다고 알리며, 서버 또한 새로 협상된 암호화 설정을 사용할 준비가 되었다고 응답한다.

#### 6. Finished
클라이언트와 서버는 서로에게 'Finished' 메시지를 암호화된 형태로 전송하여, handshake 과정이 성공적으로 완료되었음을 확인한다.

## HTTPS 통신의 전체 과정
1. 서버는 SSL 인증서를 발급받아 설치한다.
2. 클라이언트가 서버로 연결을 시도한다.
3. 서버는 Certificate 패킷을 통해 서버의 SSL 인증서를 전달한다.
4. 클라이언트는 서버의 SSL 인증서를 검증한다. CA의 공개 키를 이용해 서명을 복호화한다. 복호화하여 나온 해시 값고, 공개 키를 해시한 값(지문)이 일치한다면, 인증서가 위조되지 않았으며, 해당 CA에서 발급되었다는 것을 검증하는 것과 마찬가지이다.
5. 데이터를 암호화하기 위한 대칭 키를 생성하고, 서버의 공개키로 대칭 키를 암호화한다.
  - 정확히는 대칭 키의 재료이다.
6. 서버로 암호화된 대칭 키를 전달한다.
7. 서버는 비밀키로 대칭 키를 복호화하여 대칭 키를 얻는다.
8. 이제 서버와 클라이언트는 대칭 키를 통해 안전한 통신을 할 수 있다.












### 출처
- https://www.cloudflare.com/ko-kr/learning/ssl/what-is-https/
- https://kdeon.tistory.com/132#HTTPS%20(HTTP%20over%20SSL)-1
- https://www.stevenjlee.net/2020/11/01/%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-http-vs-https-%EA%B7%B8%EB%A6%AC%EA%B3%A0-ssl-secure-socket-layer/