# script vs module
스크립트는 일반적으로 단독으로 직접 실행 가능한 코드가 있는 파일이다. 모듈은 일반적으로 다른 프로그램에 필요한 변수나 함수를 정의해 놓고 사용하는 용도의 파일이다.

예를 들어 프로젝트 구조가 다음과 같다고 가정한다면.

```
├── module
│   ├── __init__.py
│   ├── area.py
└── run.py
```
module 패키지 아래에는 실제 사용될 함수가 선언되어 있는 파일이 존재하고, run.py은 이를 실행하는 파일이다.

```
# /module/area.py
PI = 3.14

def circle(radius):
	return PI * redius * radius

```
/module/area.py 파일은 프로그램에 필요한 함수들만 정의하고 함수들을 직접 사용하지 않으며 이를 모듈이라 볼 수 있다.

```
# /run.py
import module.area

x = 5
print('반지름의 길이가 {}인, 원의 면적은 {}이다.'.format(x, area.circle(x)))
```
/run.py 파일에는 실제로 함수들을 사용하는 코드가 있고, 이 파일을 실행시키면 함수가 실행되므로 스크립트라 볼 수 있다.

하지만 **스크립트와 모듈은 그 안에 어떤 내용을 담을지 개발자가 정할 뿐 파일 자체에 특별한 차이가 있는 건 아니다.** 그래서 어떤 파이썬 파일이든 직접 실행할 수도 있고 다른 곳에서 불러올 수 있다. 즉, 어떤 파일이든 상황에 따라 모듈이 될 수 있고 스크립트가 될 수 있다. 예를 들어 아래와 같이 /module/area.py 파일에 실행 코드를 포함하면

```
# /module/area.py
PI = 3.14

def circle(radius):
	return PI * redius * radius

x = 6

print('반지름의 길이가 {}일 때, circle 함수는 {}을 반환한다.'.format(x, circle(x)))

```
/module/area.py 파일을 함수를 테스트하는 스크립트로 사용할 수 있다. 하지만 이렇게 구현했을 때, area 모듈을 import한 app.py에서도 해당 테스트 코드가 실행되는 문제가 생길 수 있다. 그 이유는 **모듈을 import하면 모듈 안에 있는 코드가 처음부터 끝까지 모두 실행되기 떄문이다.**

## `__name__` 내장 변수

이 문제를 해결하기 위해서 `__name__`이라는 내장 변수를 사용해야 한다. `__name__`은 "이 코드가 파이썬 인터프리터에게 어떤 '모듈 이름'으로 인식되고 있는가"를 나타낸다. 

인터프리터 입장에서 모든 `.py`파일은 두 가지로만 구분한다. 파일이 직접 실행되면 `__name__`값은 `"__main__"`이 되고, 다른 코드에서 import하면, 그 파일(모듈)의 `__name__`값은 그 모듈의 **경로 이름**이 된다.

> `"__main__"`은 파이썬이 "엔트리포인트로 실행중인 코드"에 부여하는 특별한 모듈 이름이다.

예를 들어 /module/area.py 파일을 직접 실행해서 `__name__`을 출력하면 `"__main__"`이라고 출력되고, app.py 파일에서 module.area 모듈을 import하면 `__name__` 출력 값은 `"module.area"`라고 다온다.

그래서 `__name__` 내장 변수를 사용해서 파일이 직접 실행되는지, 아니면 import 되는지에 따라 코드 흐름을 제어할 수 있다. 즉, 파일을 직접 실행할 때만 실행하고 싶은 코드는 `if __name__== "__main__"` 조건문 안에 두면된다.


## import가 모듈을 찾는 방식
파이썬에서 `import`문은 `import` 문의 파일 경로를 그대로 따라가며 모듈을 찾는 것처럼 보이지만 실제로는 그렇지 않다. **`import`는 특정 파일을 직접 가리키는 동작이 아니라, 이름을 해석한 뒤 탐색 규칙에 따라 모듈을 찾는 과정이다.** `import` 동작은 크게 두 단계로 나눌 수 있다.

### 1. 이름 해석 (Name Resolution)
먼저 `import` 문이 어떤 모듈 이름을 의미하는지를 결정한다.

절대 import인 경우,
```
import module.area
```
이미 완성된 모듈 이름이 주어지므로 별도의 해석 과정이 필요 없다.

반면 상대 import인 경우,
```
from .area import circle
```
여기서 `.`은 상대 경로를 표현하는데 파일 시스템의 상대 경로가 아니라, 현재 모듈이 속한 패키지(`"__package__"` 값)를 기준으로 해석된다.

따라서 `"__package__"` 값이 설정되어 있지 않다면 상대 import는 해석 자체가 불가능하다.

> `"__package__"` 값은 모듈이 패키지 컨텍스트에서 로드될 때 결정된다. 즉, 다른 코드에서 import될 때나, -m 옵션을 통해 패키지 모듈로 실행될 때에 해당된다.

### 2. 모듈 탐색 (Module Search)
모듈 이름이 결정되면, 파이썬은 `sys.path`에 등록된 디렉토리 경로들을 앞에서부터 순서대로 탐색하며 해당 모듈이 존재하는 위치를 찾는다.
```
import sys
print(sys.path)
```
이 과정에서 실제 파일 시스템이 사용되며, 모듈을 찾는 기준은 항상 `sys.path`이다.

즉 상대 import이든 절대 import이든 탐색 단계에서는 동일하게 `sys.path`가 사용된다.

### 실행 방식에 따른 차이
스크립트를 직접 실행하는 경우에는,
```
python3 app/main.py
```
`"__package__"`값이 설정되지 않기 때문에 상대 import를 사용할 수 없다. 

반면 `-m` 옵션을 사용해 실행하면, 
```
python3 -m app.main
```
실행되는 모듈의 패키지 컨텍스트(`"__package__"`)가 유지되어 상대 import가 안정적으로 동작한다.

> 패키지 컨텍스트란 "이 코드가 어떤 패키지에 속한 모듈로 인식되고 있는가"를 표현하는 실행 맥락이다. 패키지 컨텍스트는 다른 모듈에서 import되거나, -m 옵션으로 실행될 때 생긴다. 

### 참고
- https://doyyy.tistory.com/26
- https://stackoverflow.com/questions/2996110/what-is-the-difference-between-a-module-and-a-script-in-python