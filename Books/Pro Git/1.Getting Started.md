# 1.1 About Version Control
버전 관리 시스템(VCS)는 파일에 대한 변경 사항을 시간에 따라 기록하여, 나중에 특정 시점의 버전을 다시 불러올 수 있게 해주는 시스템이다.

VCS를 사용하면 특정 파일을 이전 상태로 되돌리거나, 시간에 따른 변경 사항을 비교할 수 있다. 덕분에 작업을 망치거나 파일을 잃어버려도 쉽게 복구할 수 있다.

## 로컬 버전 관리 시스템(Local Version Control Systems)
많은 사람들이 선택하는 버전 관리 방법은 파일을 다른 디렉터리에 복사해 두는 것이다. 이 방식은 간단하지만 현재 어떤 디렉터리에서 작업하고 있는지 까먹기 쉽고 의도치 않은 파일을 수정할 수도 있다.

이런 문제를 해결하기 위해, 오래전부터 로컬 버전 관리 시스템(Local VCS)을 개발해 왔다. 이 시스템은 파일의 모든 변경 사항을 관리하기 위한 간단한 데이터베이스를 가지고 있으며, 이를 통해 파일들을 버전 관리 대상으로 추적한다.

가장 널리 사용된 VCS 도구 중 하나로 RCS(Revision Control System) 라는 시스템이 있다. RCS는 파일 전체를 저장하는 대신, 패치 집합(Patch Set), 즉 파일 간의 차이를 특수한 형식으로 디스크에 저장한다. 그런 다음 일련의 Patch Set을 적용해서 모든 파일의 특정 시점으로 되돌릴 수 있다.

## 중앙 집중형 버전 관리 시스템(Centralized Version Control System)
사람들이 다음으로 겪게 되는 주요 문제는 다른 시스템에서 작업하는 개발자들과 협업해야 한다는 점이다. 이 문제를 해결하기 위해 CVCS(중앙 집중형 VCS)가 개발되었다. **CVS, Subversion 같은 시스템은 파일을 관리하는 서버가 별도로 있고 클라이언트가 중앙 서버에서 파일을 받아서 사용(Checkout)한다.**

로컬 VCS에 비해 CVCS 환경은 VCS 하나를 관리하기 때문에 관리자가 협업하는 사람들이 누가 무엇을 하는지 꼼꼼히 관리할 수 있다.

하지만 중앙 서버를 관리하기 때문에 결점이 있기도 하다. 만약 서버가 한 동안 다운되면 그동안 아무도 다른 사람과 협업할 수 없고 백업할 방법도 없다. 그리고 중앙 데이터베이스가 있는 하드디스크에 문제가 생기면 프로젝트의 모든 히스토리를 잃는다.

## 분산 버전 관리 시스템 (Distributed Version Control System)
**Git, Mercurial, Darcs 같은 DVCS에서는 클라이언트가 단순히 파일의 최신 스냅샷만 체크아웃하는 것이 아니라, 저장소를 히스토리와 더불어 전부 복제한다**. 그래서 만약에 서버에 문제가 생기면 이 복제물로 다시 작업을 시작할 수 있다.

게대가 대부분의 DVCS 환경에서는 원격 저장소가 여러 개 존재할 수 있다. 그래서 하나의 프로젝트 안에서 서로 다른 그룹의 사람들과, 서로 다른 방식으로 협업할 수 있다. 이는 CVCS에서는 불가능했던 계층형 모델과 같은 워크플로우를 구성할 수 있게 한다.

> CVCS에서는 중앙 서버가 유일한 저장소가 되어서 모든 사람이 거기에만 직접 접근한다.

# What is Git
Git이 무엇이며 어떻게 동작하는지에 대한 기본 개념을 이해하면, Git을 효과적으로 사용할 수 있다.

## 차이가 아닌 스냅샷 (Snapshots, Not Differences)
Git과 다른 대부분의 VCS들은 파일들의 집합과, 각 파일이 시간에 따라 어떻게 변경되었는지를 기록한다. 이런 방식은 보통 델타 기반 버전 관리라고 불린다.

그림으로 생각하면 아래와 같다.
```
v1: [A.txt]
v2: v1 + (A.txt에서 2번째 줄 수정)
v3: v2 + (A.txt에서 1번째 줄 삭제)
```
그래서 저장되는 것은
- v1: 파일 전체
- v2: v1 -> v2로 가는 차이
- v3: v2 -> v3로 가는 차이

이다. 이렇게 관리했을 때, 특정 버전을 보려면 이전 변경들을 순서대로 재적용해야 한다.

Git은 이런 방식으로 저장하지 않고 데이터를 작은 파일 시스템의 연속된 스냅샷처럼 다룬다. Git에서 커밋을 할 때마다, 그 시점에 모든 파일이 어떤 모습인지 한 장의 사진처럼 기록하고, 그 스냅샷에 대한 참조를 저장한다. 효율성을 위해, 만약 어떤 파일이 이전 커밋 이후에 변경되지 않았다면 Git은 그 파일을 다시 저장하지 않고, 이미 저장되어 있는 이전의 파일을 기리키는 링크만 저장한다. 이처럼 커밋 하나에 "하나의 디렉토리 구조 + 그 안의 모든 파일 상태"를 관리해서 각 커밋은 독립적인 가상 파일 시스템 하나라고 볼 수 있다.

## 거의 모든 명령을 로컬로 실행 (Nearly Every Operation Is Local)
Git에서 대부분의 작업은 로컬 파일과 데이터로만 수행되기 때문에 네트워크에 있는 다른 컴퓨터로부터 정보를 가져올 필요가 없다. 그래서 네트워크 속도에 영향을 받는 CVCS와 비교했을 때 Git의 속도가 압도적으로 빠르다.

프로젝트의 전체 변경 이력(history)이 로켤 디스크에 모두 존재하기 때문에 명령이 순식간에 실행되며 프로젝트의 변경 이력을 살펴볼 때, 서버에 접속해 이력을 가져올 필요가 없다.

## Git은 무결성을 보장한다. (Git Has Integrity)
Git에서는 모든 데이터가 저장되기 전에 체크섬(Checksum)이 계산되며ㅕ, 이후에는 그 체크섬을 기준으로 참조된다. 이 말은 곧, Git이 모르게 어떤 파일이나 디렉터리의 내용이 변경되는 것은 불가능하다는 뜻이다. 체크섬 덕분에 데이터가 전송되는 과정에서 정보가 유실되거나 파일이 손상되더라도, Git은 이를 반드시 감지할 수 있다.

Git이 체크섬을 계산하는 데 사용하는 메커니즘은 SHA-1 해시이다. 이는 16진수 문자로 이루어진 40자리 문자열이며, Git에 저장되는 파일의 내용이나 디렉터리 구조, 커밋 객체 자체를 해싱한다.


## Git은 일반적으로 데이터를 추가만 한다. (Git Generally Only Adds Data)
Git에서 수행하는 거의 모든 작업은 Git 데이터베이스에 데이터를 추가하는 방식으로 이루어진다. 그래서 시스템이 되돌릴 수 없는 작업을 하게 만들거나, 데이터를 완전히 삭제하도록 만드는 일은 매우 어렵다. 다른 VCS처럼 Git도 커밋하지 않으면 변경사항을 잃어버릴 수 있지만, 일단 스냅샷을 커밋하고 나면 데이터를 잃어비리기 어렵다.

## 세 가지 상태 (The Three State)
Git에서 파일은 크게 세 사기 상태 중 하나에 놓이게 된다. 즉, `modified`, `staged`, `commited` 상태이다.

- Modified (수정): 파일이 변경되었지만, 아직 Git 데이터베이스에 커밋되지 않은 상태를 의미한다.
- Staged (스테이징): 수정된 파일의 현재 버전을 다음 커밋 스냅샷에 포함시키도록 표시한 상태이다.
- Commited (커밋): 데이터가 로컬 Git 데이터베이스에 안전하게 저장된 상태를 의미한다.

이 개념을 바탕으로 Git 프로젝트는 크게 세 가지 주요 영역으로 나뉜다. 작업 디렉터리(working tree), 스테이징 영역(staging area), 그리고 Git 디렉터리(Git directory)이다.

```
┌──────────────┐      git add        ┌──────────────┐      git commit     ┌────────────────┐
│ Working Tree │  ───────────────▶   │ Staging Area │  ───────────────▶   │ .git Directory │
│              │                     │ (Index)      │                     │                │
└──────────────┘                     └──────────────┘                     └────────────────┘

```
작업 디렉터리(working tree)는 프로젝트의 특정 버전 하나가 체크아웃(checkout: 꺼내다)되어 있는 상태를 의미한다. 이 안에 있는 파일들은 .git 디렉터리에 있는 압축된 데이터베이스에서 꺼내어 디스크에 배치된 것이며, 사용자가 직접 수정하거나 사용할 수 있다.

스테이징 영역(staging area)은 일반적으로 .git 디렉터리 안에 존재하는 하나의 파일로, 다음 커밋에 어떤 내용이 포함될지를 저장하는 역할을 한다. Git 내부 용어로는 `index`라고 부르지만, staging area라는 표현도 동일한 의미로 사용된다.

.git 디렉터리(Git directory)는 프로젝트에 대한 메타데이터와 객체 데이터베이스가 저장되는 곳이다. 이곳은 Git에 가장 중요한 부분으로, 다른 컴퓨터에서 저장소를 clone할 때 실제로 복사되는 대상이 이 Git directory이다.

Git의 기본적인 작업 흐름은 다음과 같다.
1. 작업 디렉터리에서 파일을 수정한다.
2. 다음 커밋에 포함시키고 싶은 변경 사항만 선별하여 스테이징한다. 이 과정에서 선택된 변경 사항만 스테이징 영역에 추가된다.
3. 커밋을 수행하면, 스테이징 영역에 있는 파일 상태를 기준으로 스냅샷이 생성되고, 이 스냅샷이 Git 디렉터리에 영구적으로 저장된다.

어떤 파일의 특정 버전이 Git 디렉터리에 있다면, 그 파일은 커밋된(commited) 상태이다. 파일이 수정된 뒤 스테이징 영역에 추가되었다면 스테이징된(staged) 상태이다. 그리고 파일이 체크아웃된 이후 수정되었지만 아직 스테이징되지 않았다면 수정된(modified) 상태이다.

### 참고
- https://git-scm.com/book/ko/v2
- https://git-scm.com/book/en/v2


