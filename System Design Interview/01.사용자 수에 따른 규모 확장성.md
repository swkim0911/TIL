# 단일 서버
모든 컴포넌트(웹 앱, DB, 캐시 등)가 한 대의 서버에서 실행되는 간단한 시스템.

<p align="center"><img width="500" alt="image 1-1" src="https://github.com/user-attachments/assets/de88f18a-ffe5-41f3-9b07-e3860351e896"></p>


1. 사용자는 도메인 이름(api.mysite.com)을 이용하여 웹사이트에 접속한다. 이 접속을 위해서 도메인 이름을 DNS에 질의하여 IP 주소로 변환하는 과정이 필요하다.
2. DNS 조회 결과로 IP 주소가 반환된다.
3. 해당 IP 주소로 HTTP 요청이 전돨된다.
4. 요청을 받은 웹 서버는 HTML 페이지나 JSON 형태의 응답을 반환한다.

실제 요청은 다음 두 가지 종류의 단말로부터 온다.
- 웹 애플리케이션
- 모바일 앱

# 데이터 베이스
사용자가 늘면 서버 하나로 충분하지 않아 여러 서버를 두어야 한다. 하나는 웹/모바일 트래픽 처리 용도고, 다른 하나는 DB용이다. 웹/모바일 트래픽 처리 서버(웹 계층)와 DB 서버(데이터 계층)를 분리하면 각각 독립적으로 확장할 수 있다.

## 어떤 데이터베이스를 사용할 것인가?

### 관계형 데이터베이스
- 자료를 테이블과 열, 컬럼으로 표현한다.
- SQL을 사용하면 여러 테이블에 있는 데이터를 그 관계에 따라 조인(join)하여 합칠 수 있다.

### 비 관계형 데이터베이스
- 일반적으로 조인 연산을 지원하지 않는다.

### 비 관계형 데이터베이스를 선택하는 경우
-  아주 낮은 응답 지연시간(latency)을 요구하는 경우
    - 응답 지연시간: 시스템에서 요청을 보낸 시점부터 그에 대한 응답이 도착하는 시점까지 걸리는 시간

-  다루는 데이터가 비정형(unstructured)이라서 관계형 데이터가 아닌 경우
   -  비정형 데이터: 고정된 구조나 스키마가 없는 데이터. 텍스트 문서, 미디어 파일, 로그 파일 등이 있다.

-  데이터(JSON, YAML, XML 등)를 직렬화하거나 역직렬화할 수 있기만 하면 되는 경우
   - 데이터 간에 (복잡한) 관계, 트랜잭션 관리가 필요한 경우 관계형 데이터베이스 사용을 고려한다. 
-  아주 많은 양의 데이터를 저장할 필요가 있는 경우

# 수직적 규모 확장 vs 수평적 규모 확장
- 수직적 규모 확장(scale up): 서버에 고사양 자원(더 좋은 CPU, RAM)을 추가하는 행위
- 수평적 규모 확장(scale out): 더 많은 서버를 추가하여 성능을 개선하는 행위

## 수직적 규모 확장의 장·단점
- 서버로 유입되는 트래픽의 양이 적을 때 좋은 선택이며 이 방법의 장점은 단순함이다.
- 하지만, 한계가 있다. 한 대의 서버에 CPU나 메모리를 무한대로 증설할 방법은 없다.
- 장애에 대한 자동복구(failover) 방안이나 다중화(redundancy) 방안을 제시하지 않는다.
  - failover: 시스템 장애가 발생했을 때, 장애가 발생한 시스템의 기능을 <U>자동으로 대체 시스템으로 전환</U>하여 서비스의 연속성을 유지하는 과정
  - redundancy: 시스템의 신뢰성과 가용성을 높이기 위해 동일한 기능을 수행하는 여러 개의 구성 요소를 중복 배치하는 전략

이런 단점 때문에 대규모 애플리케이션을 지원하는 데는 수평적 규모 확장이 적절하다.


## 로드밸런서
앞서 본 설계에서 사용자는 웹 서버에 바로 연결된다. 웹 서버가 다운되면 사용자는 웹 사이트에 접속할 수 없다. 또한, 너무 많은 사용자가 접속하여 웹 서버가 한계 상황에 도달하게 되면 응답 속도가 느려지거나 서버 접속이 불가능해질 수도 있다. 이런 문제를 해결하는 데에 로드밸런서를 도입하는 것이 최선이다.

로드밸런서는 부하 분산 집합(load balancing set)에 속한 웹 서버들에게 트래픽 부하를 고르게 분산하는 역할을 한다.

<p align="center"><img width="500" alt="image 1-4" src="https://github.com/user-attachments/assets/dcee1a24-6c1d-4901-9910-ea0c0b24830a"></p>

사용자는 로드밸런서의 공개 IP 주소로 접속하고 웹 서버는 클라이언트의 접속을 직접 처리하지 않는다. 보안을 위해, 서버 간 통신에는 사설 IP 주소가 이용된다. 부하 분산 집합에 또 하나의 웹 서버를 추가하면 no failover 문제가 해소되며, 가용성(availability)은 향상된다.
- 서버 1이 다운되면 모든 트래픽은 서버 2로 전송된다. 따라서 웹 사이트 전체가 다운되는 일이 방지된다.

- 웹 서버로 유입되는 트래픽이 증가하면 감당할 수 없는 시점이 오는데, 로드밸런서가 있으므로 웹 서버를 추가하기만 하면 된다. 그러면 로드 밸런서가 자동적으로 트래픽을 분산한다.

## 데이터베이스 다중화 (replication)
데이터베이스 서버 역시 하나이면 자동복구나 다중화를 지원하지 못한다. 데이터베이스 다중화는 이런 문제를 해결하는 보편적인 기술이다.

보통 서버 사이에 master-slave 관계를 설정하고 데이터 원본은 주 서버에, 사본은 부 서버에 저장하는 방식이다.

쓰기 연산(insert, update, delete)은 master 에만 지원하고 slave 에는 읽기 연산만 지원한다. 읽기 연산의 비중이 쓰기 연산보다 많기 때문에 slave 수가 master 보다 많다.

<p align="center"><img width="500" alt="image 1-5" src="https://github.com/user-attachments/assets/31427923-2263-4964-a46b-dc4b5681347e"></p>

- 더 나은 성능: 분산된 slave 데이터베이스에 병렬로 처리될 수 있는 query 수가 늘어나므로, 성능이 좋아진다.
  
- 안정성(reliability): 데이터를 지역적으로 다중화시켜 놓을 수 있기 때문에 서버 일부가 파괴되어도 데이터는 보존될 것이다.

- 가용성(availability): 여러 지역에 복제함으로써, 하나의 서버에 장애가 발생해도 다른 서버의 데이터를 가져와 계속 서비스를 할 수 있다.

master 데이터베이스가 하나인데 다운되는 경우, slave가 새로운 master가 되고 새로운 slave가 생길 것이다. 운영 환경에서는 이것보다 더 복잡한데, slave에 보관된 데이터가 최신 상태가 아닐 수 있기 때문이다. 없는 데이터는 복구 스크립트(recovery script)를 돌려 추가해야 한다. 다중 마스터(multi-masters)나 원형 다중화(circular replication)을 도입하면 이런 상황을 대처하는데 도움이 된다.
- multi-masters: 다중 마스터는 write 연산을 수락하는 여러 노드가 데이터베이스 클러스터에 있다. 하나의 master에서 업데이트가 이루어지면 클러스터의 다른 모든 master 노드에 비동기식으로 전파되어 데이터가 최종적으로 일관성을 유지하게 된다.

# 캐시
캐시는 값비싼 연산 결과나 자주 참조되는 데이터를 메모리 안에 두고, 뒤이은 요청이 빨리 처리될 수 있도록 하는 저장소이다. 앱의 성능은 데이터베이스를 얼마나 자주 호출하느냐에 크게 좌우되는데, 캐시는 그런 문제를 완화할 수 있다.

## 캐시 계층
캐시 계층을 두면 성능 뿐만 아니라 데이터베이스의 부하를 줄일 수 있고 캐시 계층의 규모를 독립적으로 확장시킬 수 있다.

<p align="center"><img width="500" alt="image 1-7" src="https://github.com/user-attachments/assets/0c201b87-e209-4bf9-87a1-8990291d22d2"></p>

위와 같은 캐시 전략을 읽기 주도형 캐시 전략(read-through caching strategy)이라고 부른다. 이외에도 다양한 캐시 전략이 있는데 캐시할 데이터 종류, 크기, 액세스 패턴에 맞는 캐시 전략을 선택하면 된다.

## 캐시 사용시 유의할 점
- 데이터 갱신은 자주 일어나지 않지만 참조는 빈번하게 일어난다면 고려해볼만 한다.
- 캐시는 데이터를 휘발성 메모리에 두므로, 영속적으로 보관할 데이터를 캐시에 두는 것은 바람직하지 않다.
- 캐시 내 데이터 만료에 대한 정책을 마련해 두는 게 좋다.
- 저장소의 원본을 갱신하는 연산과 캐시를 갱신하는 연산이 단일 트랜잭션으로 처리되지 않는 경우 이 일관성은 깨질 수 있다.
- SPOF(Single Point Of Failure)를 피하려면 여러 지역에 걸쳐 캐시 서버를 분산시켜야 한다.
- 캐시 메모리가 너무 작으면 데이터가 자주 캐시에서 밀려나버려(eviction) 성능이 떨어지게 된다. 캐시 메모리 과할당(overprovision)으로 이를 막을 수 있다.
- 데이터 방출(eviction) 정책이란 캐시가 꽉 차버리면 추가로 데이터를 넣어야 할 경우 기존 데이터를 내보내는 것을 말한다. 널리 쓰이는 것으로 LRU(Least Recently Used - 사용된 빈도가 가장 낮은 데이터를 내보내는 정책)가 있다.

# 콘텐츠 전송 네트워크(CDN)
CDN은 정적 콘텐츠를 전송하는 데 쓰이는, 지리적으로 분산된 서버의 네트워크이다. CDN을 통해 정적 콘텐츠를 캐싱한다. 정적 콘텐츠는 더 이상 웹 서버를 통해 서비스하지 않으며, CDN을 통해 제공하여 더 나은 성능을 보장한다.

## CDN 사용 시 고려해야 할 사항
- 비용
- 적절한 만료 시한 설정
- CDN 장애에 대한 대처 방안
- 콘텐츠 무효화(invalidation) 방법

# 무상태(stateless) 웹 계층
웹 계층을 수평적으로 확장하기 위해선 상태 정보(세션 데이터와 같은)를 웹 계층에서 제거하고 RDBMS 나 NoSQL 같이 지속성 저장소에 보관하고 필요할 때 가져오도록 하는 것이다. 이렇게 구성된 웹 계층을 무상태 웹 계층이라고 한다.

## 상태 보존 의존적인 아키텍처
상태 정보(클라이언트 정보)를 서버에서 보관한다면 같은 클라이언트로부터 요청은 항상 같은 서버로 전송되어야 한다. 로드밸런서가 이를 지원하기 위해 고정 세션(sticky session)이라는 기능을 제공하는데 이는 로드밸런서에 부담을 준다.

## 무상태 아키택처
무상태 아키택처인 경우, 웹 서버는 상태 정보가 필요한 경우 공유 저장소로부터 데이터를 가져온다. 이런 구조는 단순하고 안정적이며 규모 확장이 쉽다.

<p align="center"><img width="500" alt="image 1-14" src="https://github.com/user-attachments/assets/ac793983-4f36-4e95-b704-7c8a5087c525"></p>

그림에서 세션 데이터를 웹 계층에서 분리하고 지속성 데이터 보관소에 저장하도록 만들었다. 저장소는 RDBMS, Redis 같은 캐시 시스템일 수 있으며, 여기서는 규모 확장이 편한 NoSQL을 사용했다. 상태 정보가 웹 서버들로부터 제거되어, 트래픽 양에 따라 웹 서버를 넣거나 빼기만 하면 자동으로 규모를 확장할 수 있게 되었다.

# 데이터 센터
가용성을 높이고 전 세계 어디서도 쾌적하게 사용할 수 있도록 하기 위해서는 데이터 센터를 지원하는게 필수다. 장애가 없는 상황에서 사용자는 가장 가까운 데이터 센터로 안내되는데, 이 절차를 지리적 라우팅(geoDNS-routing)이라고 부른다. 지리적 라우팅에서의 geoDNS는 사용자의 위치에 따라 도메인 이름을 어떤 IP 주소로 변환할지 결정할 수 있도록 해주는 DNS 서비스다.

다중 데이터센터 아키텍처를 만들려면 몇 가지 기술적 난제를 해결해야 한다.
- 트래픽 우회: 데이터 센터 중 하나에 장애가 발생하면 올바른 데이터 센터로 트래픽을 보내는 효과적인 방법을 찾야야 한다.

- 데이터 동기화

- 테스트와 배포: 자동화된 배포 도구는 모든 데이터 센터에 동일한 서비스가 설치되도록 하는 데 중요한 역할을 한다.

# 메시지 큐
메세지 큐는 메시지의 무손실을 보장하는 비동기 통신(asynchronous communication)을 지원하는 컴포넌트이다. 메시지 큐를 이용하면 서비스 또는 서버 간 결합이 느슨해져서, 규모 확장성이 보장되어야 하는 안정적 애플리케이션을 구성하기 좋다.

# 로그, 메트릭 그리고 자동화
몇 개 서버에서 실행되는 소규모 웹 사이트를 만들 때는 로그나 메트릭, 자동화 같은 것은 하면 좋지만 꼭 할 필요는 없다. 하지만 웹 사이트와 함께 사업 규모가 커지고 나면, 이런 도구에 필수적으로 투자해야 한다.
- 로그: 로그를 단일 서비스로 모아주는 도구를 활용하면 더 편리하게 검색하고 조회할 수 있다.
- 메트릭: 메트릭을 잘 수집하면 사업 현황에 관한 유용한 정보를 얻을 수도 있고, 시스템의 현재 상태를 손쉽게 파악할 수도 있다.
- 자동화: 지속적 통합(continuous integration) 외에도 빌드, 테스트, 배포 등의 절차를 자동화하여 개발 생산성을 향상시킬 수 있다.

## 메시지 큐, 로그, 메트릭, 자동화 등을 반영한 설계안

<p align="center"><img style="width:50%; height:auto;" alt="image 1-19" src="https://github.com/user-attachments/assets/10398e08-86ab-4db0-939a-dfbac2e59e98"></p>

# 데이터베이스의 규모 확장
저장할 데이터가 많아지면 데이터베이스에 대한 부하도 증가한다.

## 수직적 확장 (scale up)
기존 서버에 더 많은, 또는 고성능의 자원(RAM, 디스크 등)을 증설하는 방법이다. 수직적 확장의 약점으로 다음과 같다.
- 하드웨어 증설 한계
- SPOF(Single Point Of Failure)
- 비용

## 수평적 확장
데이터베이스의 수평적 확장은 샤딩(shading)이라고도 부르는데, 더 많은 서버를 추가함으로써 성능을 향상시킬 수 있다. 샤딩은 대규모 데이터베이스를 샤드(shard)라고 부르는 작은 단위로 분할하는 기술을 말한다. 모든 샤드는 같은 스키마를 쓰지만 샤드에 보관되는 데이터 사이에는 중복이 없다.

샤딩 전략을 구현할 때 고려해야 할 중요한 것은 샤딩 키를 어떻게 정하느냐 하는 것이다. 샤딩 키는 데이터가 어떻게 분산될지 정하는 하나 이상의 칼럼으로 구성된다. **샤딩 키를 정할 때는 데이터를 고르게 분할 할 수 있도록 하는 게 중요하다.** 샤딩을 도입하면 시스템이 복잡해지고 풀어야 할 문제도 생긴다.
- 데이터의 재 샤딩: 샤드 소진(shard exhaustion)이 발생하면 샤드 키를 계산하는 함수를 변경하고 데이터를 재배치해야 한다.

- 유명인사(celebrity) 문제: 핫스팟 키(hotspot key) 문제라고도 부르는데, 특정 샤드에 질의가 집중되어 서버에 과부하가 걸리는 문제다.
  
- 조인과 비정규화: 여러 샤드에 걸친 데이터를 조인하기가 힘들어진다. 해결 방법으로는 데이터베이스를 비정규화하여 하나의 테이블에 질의가 수행될 수 있도록 하는 것이다.

