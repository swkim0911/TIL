# 분산 시스템 환경에서의 유일 ID 생성
분산 시스템 환경에서는, 하나의 DB 서버에서 Auto Increment으로 유일한 ID를 생성하는데 부담이 된다. 그렇다고 여러 DB 서버를 두면 서버 내 ID는 유일성을 보장하지만 서버 전체 범위에서의 유일성은 보장되지 않는다.

# 1. 설계 범위
- ID는 유일하고 숫자로만 구성된다.
- ID는 64bit로 표현될 수 있는 값이어야 한다. (2^64-1: 20자리)
- ID는 발급 날짜에 따라 정렬 가능해야 한다. (ID는 시간의 흐름에 따라 커진다.)
- 초당 10,000개의 ID를 만들 수 있어야 한다.

# 2. 분산 시스템에서 유일성이 보장되는 ID를 만드는 방법

## 다중 마스터 복제 (mulit-master replication)
다중 마스터 복제 환경에서 여러 데이터베이스 서버가 각각 ID를 생성하고 이를 고정 값 k만큼 증가시켜 유일한 id를 생성한다. k는 서버 수를 나타낸다. 예를 들어, 서버가 3개라면 첫 번째 서버는 0, 3, 6 .. 두 번째 서버는 1, 4, 7 .. 세 번째 서버는 2, 5, 8 .. 로 ID를 생성한다.

하지만 단점으로 서버를 추가/삭제할 경우 k 값이 바뀌기 때문에 정상적으로 동작하기 어렵다.그리고 시간의 흐름에 따라 ID 값이 커지는 것을 보장할 수 없다.

## UUID
UUID는 컴퓨터 시스템에 저장되는 정보를 유일하게 식별하기 위한 128비트 수이며 충돌 가능성이 지극히 낮다. 
> 위키피디아에 따르면 중복 UUID가 생길 확률로 50%로 끌어 올리려면 초당 10억 개의 UUID를 100년 동안 계속해서 만들어야 한다.

UUID는 서버 간 조율 없이 독립적으로 생성 가능하다. 따라서 각 웹 서버는 별도의 ID 생성기를 사용해 유일한 ID를 만들어 낸다.

하지만 UUID는 시간순으로 정렬할 수 없고 숫자가 아닌 값이 포함될 수 있다.

## 티켓 서버
 이 방식은 auto_increment 기능을 갖춘 데이터베이스 서버, 즉 티켓 서버를 중앙 집중형으로 하나만 사용하는 것이다. 
 
장점
 - 유일성이 보장되는 숫자로만 구성된 ID를 쉽게 만들 수 있다.
 - 구현하기 쉽고, 중소 규모 애플리케이션에 적합하다.

단점
- SPOF(Single Point Of Failure) 문제가 있다. 이 이슈를 피하기 위해 여러 서버를 둔다면 동기화 같은 새로운 문제가 발생한다.

> Flickr라는 기업에서는 샤딩을 할 때 각 DB 서버의 기본 키가 전역적으로 고유하게 하기 위해 티켓 서버를 사용한다고 한다. - https://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/ 
## 트위터 스노플레이크 접근법
지금까지 살펴본 모든 방법은 요구사항을 모두 해결하지 못했다. 트위터는 이 문제를 스노플레이크(snowflake)라고 부르는 독창적인 ID 생성 기법을 만들어 해결했다. 이 방식은 Discord 및 Instagram을 포함한 다른 회사에서도 사용된다.

스노플레이크 형식의 ID는 64bit 바이너리이며 총 5개의 절(section)으로 나뉜다. 절 순서대로 간략히 설명해보자면 아래와 같다.

- 사인(sign) 비트: 1비트를 할당한다. 나중을 위해 확보해둔 비트로, 음수/양수를 구분하는데 사용할 수 있다.

- 타임스탬프(timestamp): 41비트를 할당한다. Epoch Time 이후로 몇 밀리세컨드가 경과했는지 나타낸다. 41비트를 십진수로 변경하고 트위터 epoch time을 더해 결과로 얻어진 밀리초 값을 UTC 시각으로 변환하면 언제 생성된 ID인지 알 수 있다. 
  - 41비트이므로 최대 69년(2^41 ms)의 시간을 표현할 수 있다.
  
- 데이터센터 ID: 5비트를 할당한다. 2^5, 즉 32개의 데이터 센터를 사용할 수 있다.

- 서버 ID: 5비트를 할당한다. 2^5, 즉 데이터센터별 32개의 서버를 사용할 수 있다.
  - 즉, 10비트는 컴퓨터 ID를 나타낸다.

- 일련번호: 12비트를 할당한다. 각 서버는 ID를 생성할 때 마다 이 일련번호를 1씩 증가시킨다. 이 값은 1ms가 경과할 때 마다 0으로 초기화 된다. 따라서 각 타임스탬프마다 일련번호가 생긴다.

정리하면, ID에 타임 스탬프 값을 넣어두기 때문에 시간순으로 정렬이 가능하다. 또한 데이터 센터 ID와 서버 ID를 사용하여 서로 다른 서버에서 같은 시각에 생성한 ID라고 하더라도 충돌이 발생하지 않는다. 또한 내부적으로 일련번호를 사용하여 같은 서버에서 생성한 ID도 충돌이 발생하지 않는다. 이 과정은 서버간 동기화가 필요 없으므로, 확장에 유리하다. ID 전체 길이도 딱 64비트라서 모든 요구사항을 만족한다.