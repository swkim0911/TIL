# Garbage Collection in JVM

## 가비지 컬렉션이란?
가비지 컬렉션이란 JVM 안의 힙 메모리를 감시하여, 어떤 객체가 사용 중인지·사용되지 않는지 식별하고, 사용되지 않는 객체를 삭제하는 과정이다. 여기서 사용 중인 객체(또는 참조되고 있는 객체)란 프로그램의 어떤 부분에서든 그 객체를 가리키는 포인터(참조)를 유지하고 있는 경우를 말한다. 반면, 사용되지 않는 객체(또는 참조되지 않는 객체)는 프로그램의 어떤 부분에서든 여전히 그 객체를 가리키는 포인터를 유지하고 있지 않은 경우를 말한다.

C, C++ 같은 언어는 메모리 해제가 수동으로 이루어지며, Java는 매모리 해제 과정이 가비지 컬렉터에 의해 자동으로 처리된다.

## Java에서 가비지 컬렉션
Java HotSpot Virtual Machine에서는 여러 종류의 가비지 컬렉션 알고리즘을 포함한다. 이 알고리즘들은 힙에 살아있는 객체를 매번 검사하는게 아니라 아래와 같은 "week generational hypothesis" 라는 가설을 바탕으로 설계되어 있다.

- 대부분의 객체는 생성된 후 아주 짧은 시간만 살아남는다.
- 오래 살아남은 객체는 더욱 오래 산다.
- (+) 오래된 객체에서 젊은 객체로의 참조는 아주 적게 존재한다.

이렇게 생성된 객체는 대부분 짧은 시간안에 사라지거나, 사라지지 않은 객체는 계속해서 살아가는 가설 때문에 Heap 영역을 Young, Old 영역(세대: generation)으로 나누어 설계된다. 이렇게 여러 세대로 관리함으로써 좀 더 최적화해서 메모리를 관리할 수 있다.

## Minor GC와 Major GC
Young, Old 영역(세대)에서 세대(generation)란 객체를 보관하는 메모리 풀(memory pool)을 말하며 각 세대가 가득 차면, 그 세대에 대해 가비지 컬렉션이 수행된다.

### Young 영역(Young Generation)
- 대부분의 새로 생성된 객체는 이곳에 생성된다.
- 대부분의 객체는 이 영역에서 사라지게 된다.
- Young 영역이 가득 차서 발생하는 가비지 컬렉션을 Minor GC라고 부른다.

### Old 영역(Old Generation)
- Young 영역에서 Reachable(참조되고 있는) 상태를 유지하여 살아남은 객체가 복사되는 영역
- Young 영역보다 크게 할당된다.
- Old 영역에 대한 가비지 컬렉션을 Major GC라고 부른다.

Old 영역에 Young 영역보다 크게 할당된 이유는 앞서 말한 가설과 연결되어 있다. Young 영역은 빠르게 죽는 객체를 빠르게 정리하는 목적을 갖고 있기 때문에 그 크기가 작아야 효율적이며 Old 영역에 있는 객체는 더 오래 살거라는 가설 아래에 오래, 넉넉하게 관리함으로써 GC 빈도를 낮추는 것이다.

Old 영역에 있는 객체가 Young 영역의 객체를 참조하는 경우는 어떻게 GC가 동작하는지 의문이 들 수 있다. 이러한 경우에 "오래된 객체에서 젊은 객체로의 참조는 아주 적게 존재한다."라는 가설 하에 Old 영역에는 512 bytes의 덩어리(chunk)로 되어 있는 카드 테이블(card table)이 존재한다.

카드 테이블에는 Old 영역에 있는 객체가 Young 영역의 객체를 참조할 때마다 정보가 표시된다. 그래서 Minor GC가 동작할 때 Old 영역에 있는 모든 객체의 참조를 확인하지 않고, 이 카드 테이블만 뒤져서 GC 대상인지 식별한다.

## 가비지 컬렉션의 동작 방식

Young 영영과 Old 영역은 메모리 영역에 구분되어 세부적인 동작 방식은 서르 다르다. 하지만 기본적으로 가비지 컬렉션이 실행된다고 하면 다음의 2가지 공통적인 단계를 따른다.

#### 1. Stop The World
Stop The World란 GC를 실행하기 위해 JVM이 애플리케이션 실행을 멈추는 것이다. **Stop The World가 발생하면 GC를 실행하는 쓰레드를 제외한 나머지 쓰레드는 모두 작업을 멈춘다.** GC 작업을 완료한 이후에 중단했던 작업을 다시 시작한다. 어떤 GC 알고리즘을 사용하더라고 Stop The World는 발생하며 대개의 경우 GC 튜닝이란 이 Stop The World 시간을 줄이는 것이다.

#### 2. Mark and Sweep
- Mark: 살아 있는 객체(reachable objects)를 표시하는 작업
- Sweep: Mark 단계에서 표시되지 않은 객체를 삭제하여 메모리를 반환하는 작업

Mark 단계에서는 GC Root에서 시작해 도달 가능한 모든 객체를 탐색하고(mark), Sweep 단계에서는 mark되지 않은(unreachable) 객체를 제거하여 메모리를 회수한다.

> GC Root는 GC가 객체 탐색을 시작하는 출발점으로 GC Root에서 직·간접적으로 참조된 모든 객체는 GC되지 않는다. GC Root는 예를 들어 로컬 스택에 저장된 메서드의 지역 변수가 있다.


### Minor GC의 동작 방식
Minor GC의 동작을 이해하기 전에 Young 영역의 구조에 대해 알아야 한다. Young 영역은 1개의 Eden 영역과 2개의 Survivor 영역으로 구성된다.
- Eden 영역: 새로 생성된 객체가 할당(Aollocation)되는 영역
- Survivor 영역: 최소 1번 이상의 GC로부터 살아남은 객체가 존재하는 영역

객체가 새로 생성되면 Young 영역의 Eden 영역에 할당되며 Eden 영역이 꽉 차면 Minor GC가 발생한다. Minor GC의 동작 과정을 보면 다음과 같다.

1. Eden 영역이 꽉차서 Minor GC가 발생한다.
2. Eden 영역의 모든 살아있는 객체는 목적지 Survivor로 복사되고 나머지는 정리된다.
3. 뿐만 아니라 현재 Survivor안에 객체가 있고 살아남는 객체가 있으면 목적지 Survivor로 복사되고 나머지는 정리된다.

이 과정에서 주의할 점은 Survivor 영역 중에 1개는 반드시 사용이 되어야 한다. 만약 두 Survivor 영역에 모두 데이터가 존재하거나 모드 사용량이 0이라면 현재 시스템이 정상적인 상황이 아님을 파악할 수 있다.

Minor GC 과정에 또 다른 절차가 있는데 바로 객체 aging(Tenuring)이다. Minor GC에서 끝나면 객체 각각은 age 값이 증가한다.

Young 영역에서 Old 영역으로 객체가 이동하는 경우는 대표적으로 두 가지이다. 하나는 Minor GC 중에서 목적지 Survivor 공간이 부족할 때이고, 다른 하나는 객체의 age가 일정 값(Tenuring Threshold)을  초과했을 때이다. 이렇게 객체의 Young -> Old 이동 과정을 Promotion이라고 한다.

### Major GC의 동작 방식
앞서 Young 영역에서 Old 영역으로 Promotion되는 조건을 알 수 있었다. 그리고 Major GC는 객체들이 계속 Promotion되어 Old 영역의 메모리가 부족해지면 발생하게 된다. Young 영역은 Old 영역보다 훨씬 작고 Copying 기반으로 처리되기 때문에 Minor GC는 일반적으로 매우 빠르게 끝난다. 하지만 Old Generation은 크기가 크고 객체 간 참조 관계도 복잡하기 때문에 Old 영역을 대상으로 하는 Major GC는 GC 알고리즘에 따라 시간이 더 오래 걸릴 수 있습니다.

참고로 Young 영역과 Old 영역을 동시에 처리하는 GC는 Full GC라고 한다.
  
### 출처
- https://docs.oracle.com/en/java/javase/21/gctuning/introduction-garbage-collection-tuning.html#GUID-326EB4CF-8C8C-4267-8355-21AB04F0D304
- https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html
- https://mangkyu.tistory.com/118
- https://d2.naver.com/helloworld/1329
- https://www.baeldung.com/java-gc-roots
