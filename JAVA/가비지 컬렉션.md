# Garbage Collection in JVM

## 가비지 컬렉션이란?
가비지 컬렉션이란 JVM 안의 힙 메모리를 감시하여, 어떤 객체가 사용 중인지·사용되지 않는지 식별하고, 사용되지 않는 객체를 삭제하는 과정이다. 여기서 사용 중인 객체(또는 참조되고 있는 객체)란 프로그램의 어떤 부분에서든 그 객체를 가리키는 포인터(참조)를 유지하고 있는 경우를 말한다. 반면, 사용되지 않는 객체(또는 참조되지 않는 객체)는 프로그램의 어떤 부분에서든 여전히 그 객체를 가리키는 포인터를 유지하고 있는 경우를 말한다.

C, C++ 같은 언어는 메모리 해제가 수동으로 이루어지며, Java는 매모리 해제 과정이 가비지 컬렉터에 의해 자동으로 처리된다.

## Java에서 가비지 컬렉션
Java HotSpot Virtual Machine에서는 여러 종류의 가비지 컬렉션 알고리즘을 포함한다. 이 알고리즘들은 힙에 살아있는 객체를 매번 검사하는게 아니라 아래와 같은 "week generational hypothesis" 라는 가설을 바탕으로 설계되어 있다.

- 대부분의 객체는 생성된 후 아주 짧은 시간만 살아남는다.
- 오래 살아남은 객체는 더욱 오래 산다.
- (+) 오래된 객체에서 젊은 객체로의 참조는 아주 적게 존재한다.

이렇게 생성된 객체는 대부분 짧은 시간안에 사라지거나, 사라지지 않은 객체는 계속해서 살아가는 가설 때문에 Heap 영역을 Young, Old 영역(세대: generation)으로 나누어 설계된다. 이렇게 여러 세대로 관리함으로써 좀 더 최적화할 수 있다.

## Minor GC와 Major GC
Young, Old 영역(세대)에서 세대(generation)란 객체를 보관하는 메모리 풀(memory pool)을 말하며 각 세대가 가득 차면, 그 세대에 대해 가비지 컬렉션이 수행된다.

### Young 영역(Young Generation)
- 대부분의 새로 생성된 객체는 이곳에 생성된다.
- 대부분의 객체는 이 영역에서 사라지게 된다.
- Young 영역이 가득 차서 발생하는 가비지 컬렉션을 Minor GC라고 부른다.

### Old 영역(Old Generation)
- Young 영역에서 Reachable(참조되고 있는) 상태를 유지하여 살아남은 객체가 복사되는 영역
- Young 영역보다 크게 할당된다.
- Old 영역에 대한 가비지 컬렉션을 Major GC라고 부른다.

Old 영역에 Young 영역보다 크게 할당된 이유는 앞서 말한 가설과 연결되어 있다. Young 영역은 빠르게 죽는 객체를 빠르게 정리하는 목적을 갖고 있기 때문에 그 크기가 작아야 효율적이며 Old 영역에 있는 객체는 더 오래 살거라는 가설 아래에 오래, 넉넉하게 관리함으로써 GC 빈도를 낮추는 것이다.

Old 영역에 있는 객체가 Young 영역의 객체를 참조하는 경우는 어떻게 GC가 동작하는지 의문이 들 수 있다. 이러한 경우에 "오래된 객체에서 젊은 객체로의 참조는 아주 적게 존재한다."라는 가설 하에 Old 영역에는 512 bytes의 덩어리(chunk)로 되어 있는 카드 테이블(card table)이 존재한다.

카드 테이블에는 Old 영역에 있는 객체가 Young 영역의 객체를 참조할 때마다 정보가 표시된다. 그래서 Minor GC가 동작할 때 Old 영역에 있는 모든 객체의 참조를 확인하지 않고, 이 카드 테이블만 뒤져서 GC 대상인지 식별한다.

## 가비지 컬렉션의 동작 방식

Young 영영과 Old 영역은 메모리 영역에 구분되어 세부적인 동작 방식은 서르 다르다. 하지만 기본적으로 가비지 컬렉션이 실행된다고 하면 다음의 2가지 공통적인 단계를 따른다.

#### 1. Stop The World
Stop The World란 GC를 실행하기 위해 JVM이 애플리케이션 실행을 멈추는 것이다. Stop The Wolrd가 발생하면 GC를 실행하는 쓰레드를 제외한 나머지 쓰레드는 모두 작업을 멈춘다. GC 작업을 완료한 이후에 중단했던 작업을 다시 시작한다. 어떤 GC 알고리즘을 사용하더라고 Stop The World는 발생하며 대개의 경우 GC 튜닝이란 이 Stop The World 시간을 줄이는 것이다.

#### 2. Mark and Sweep
- Mark: 살아 있는 객체(reachable objects)를 표시하는 작업
- Sweep: Mark 단계에서 표시되지 않은 객체를 삿제하여 메모리를 반환하는 작업

Mark 단계에서는 GC Root에서 시작해 도달 가능한 모든 객체를 탐색하고(mark), Sweep 단계에서는 mark되지 않은(unreachable) 객체를 제거하여 메모리를 회수한다.

> GC Root는 GC가 객체 탐색을 시작하는 출발점으로 GC Root에서 직·간접적으로 참조된 모든 객체는 GC되지 않는다. GC Root를 예로 들어 로컬 스택에 저장된 메서드의 지역 변수가 있다.




  












### 출처
- https://docs.oracle.com/en/java/javase/21/gctuning/introduction-garbage-collection-tuning.html#GUID-326EB4CF-8C8C-4267-8355-21AB04F0D304

- https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html

- https://mangkyu.tistory.com/118

- https://d2.naver.com/helloworld/1329

- https://www.baeldung.com/java-gc-roots